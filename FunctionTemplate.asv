function [ param ] = mySetup(shape)
%% Modify the following function for your setup function

% Copy course parameters
param.constraints = shape.constraints;
param.tolerances = shape.tolerances; 
param.eps_r = shape.eps_r;      
param.eps_t = shape.eps_t;      
param.start = shape.start;      
param.target = shape.target;     
param.Wmax = shape.Wmax;       
param.Tf = shape.Tf;    

% This is how to set the sampling interval
param.Ts = 0.05;

% This is a sample way to send reference points
param.xTar = shape.target(1);
param.yTar = shape.target(2);

% Horizon length
param.N = 15;

% How much before Ts to contraint final position
param.advance = 0.95;

% Load model parameters and calculate matrices
param.craneParams = load('Crane_NominalParameters.mat');

end % End of mySetup






function r = myTargetGenerator(x_hat, param)
%% Modify the following function for your target generation

persistent t
if isempty(t)
    t = 0;
else
    t = t + param.Ts;
end

% initial x
persistent x_initial
if isempty(x_initial)
    x_initial = x_hat;
end

t_target = t + param.N * param.Ts;
t_reach = param.advance * param.Tf;
delta_x = param.xTar - x_initial(1);
delta_y = param.yTar - x_initial(3);
if t_target >= t_reach
    % Make the crane go to (xTar, yTar)
    r(1,1) = param.xTar;
    r(3,1) = param.yTar;
else
    ratio = t_target / t_reach;
    r(1,1) = x_initial(1) + ratio * delta_x;
    r(3,1) = x_initial(3) + ratio * delta_y;
end

end % End of myTargetGenerator





function x_hat = myStateEstimator(u, y, param)
%% Modify the following function for your state estimator (if desired)

% Create the output array of the appropriate size. This vector is passed
% into myMPController, so its size must match what is expected by the code
% there.
x_hat = zeros(8,1);

% By default, just pass the system measurements through
x_hat( 1:length(y),1 ) = y;

end % End of myStateEstimator




%% Modify the following function for your controller
function u = myMPController(r, x_hat, param)

%% Do not delete this line
% Create the output array of the appropriate size
u = zeros(2,1);
%

% horizon length
N = param.N;

% objective function (w contains N+1 x vectors and N u vectors)
objFunc = @(w) objFuncN(w, N);

% inital guess w0
persistent w0
if isempty(w0)
    w0 = zeros(13*N+10, 1);
else
    w0(1:13*N) = w0(11:13*N+10);
end

% linear inequality constraint
A = [];
b = [];

% linear equality constraints (currently only equality constraint on x0)
Aeq = leftEquality(N);
beq = rightEquality(N);

% non-linear constraints
nonlcon = @(w) nonLinearConstraints(param.Ts, param.craneParams, w);

% lower and upper bounds
wLen = N*13+10;
lb = -uConstraint(wLen);
ub = uConstraint(wLen);

% options
options = optimoptions(@fmincon);

% optimisation
w = fmincon(objFunc,w0,A,b,Aeq,beq,lb,ub,nonlcon,options);

% extract u from w
u = w(11:12);

end % End of myMPController







%% objective function

function out = objFuncN(w, N)
    out = 0;
    for i = 1:13:N*13
        out = out + workOfStep(w(i:i+22));
    end
end

function out = workOfStep(xuxVec)
    x = xuxVec(1:10);
    u = xuxVec(11:13);
    x_next = xuxVec(14:23);
    workX = max(0, u(1) * (x(2) + x_next(2))) / 2; % /2 is not really needed
    workY = max(0, u(2) * (x(4) + x_next(4))) / 2; % /2 is not really needed
    out = workX + workY;
end


%% linear inequality constraint
function A = leftInequality(N)
    tmp = [zeros(8, 13*N), eye(8), zeros(8,2)];
    A = [tmp; -tmp];
end

function b = rightInequality(N, trgt)
    
end


%% linear equality constraints
function Aeq = leftEquality(N)
    selectLandLDot = [zeros(1,11), 1, 0; 
                      zeros(1,11), 0, 1];
    constraintLandLDots = kron(eye(N), selectLandLDot);
    Aeq = blkdiag(eye(10),constraintLandLDots);
end

function beq = rightEquality(N)
    LandLDotConstraintSingle = [param.craneParams.r;0];
    LandLDotConstraints = kron(ones(N+1,1), LandLDotConstraintSingle);
    beq = [x_hat(1:8); LandLDotConstraints];
end


%% non-linear constraints

function x = w2x(w)
    x = zeros((length(w)-10)/13*10, 1);
    for i=1:(length(w)-10)/13
        x(i*10-9:i*10) = w(i*13+1:i*13+10);
    end
end

function x = w2x_wave(w)
    x = zeros((length(w)-10)/13*10, 1);
    for i=1:(length(w)-10)/13
        x(i*10-9:i*10) = w(i*13-12:i*12-3);
    end
end

function u = w2u(w)
    u = zeros((length(w)-10)/13*3, 1);
    for i=1:(length(w)-10)/13
        u(i*3-1:i*3) = w(i*13-2:i*13);
    end
end

function x = doStep(x_wave, u, dt, craneParams) %why 3 u inputs???
    x = x_wave;
    for i = 1:length(x_wave)/10
        x_before = x_wave(i*10-9:i*10);
        odeFun = @(t,y) crane_nl_model_student([u(i*3-1:i*3)], y, craneParams);
        [~, y] = ode45(odeFun, [0 dt], x_before);
        x(i*10-9:i*10) = y(1);
    end
end

function [c, ceq] = nonLinearConstraints(dt, craneParams, w)
    c = [];
    ceq = w2x(w) - doStep(w2x_wave(w), w2u(w), dt, craneParams);
end


%% lower and upper bounds
function ub = ubConstraint(w_len)
    ub = Inf * ones(w_len, 1);
    for i=0:13:w_len
        ub(i+11:i+12) = ones(2,1); % u < 1
    end
    ub(w_len-9:i+12) = ones(2,1); % u < 1
end

% function Fl = initialFl(craneParams, x0)
%     dx = zeros(10, 1);
%     % Extract the crane parameters
%     Tx = craneParams.Tx; % friction coefficient
%     Ty = craneParams.Ty; % friction coefficient
%     Tl = craneParams.Tl; % friction coefficient
%     Vx = craneParams.Vx; % force coefficient
%     Vy = craneParams.Vy; % force coefficient
%     Vl = craneParams.Vl; % force coefficient
%     MR = craneParams.MR; % mass of rail
%     M  = craneParams.M; % mass of cart
%     m  = craneParams.m; % mass of pendulum
%     % This we don't change - after all, all experiments are done on Earth :)
%     g  = 9.81;
%     % Extract the states
%     x1 = x(1); % x
%     x2 = x(2); % x dot
%     x3 = x(3); % y
%     x4 = x(4); % y dot
%     x5 = x(5); % theta
%     x6 = x(6); % theta dot
%     x7 = x(7); % phi
%     x8 = x(8); % phi dot
%     x9 = x(9); % l
%     x10 = x(10); % l dot
%     
%     syms fl
%     dx10 = (cos(x5) .* g .* m .^ 2 .* (M .* cos(x5) .^ 2 + MR) .* cos(x7) .^ 3 + m .* (M .* (Tl .* x10 - fl) .* cos(x5) .^ 2 + M .^ 2 .* x6 .^ 2 .* x9 + x6 .^ 2 .* x9 .* MR .* M + MR .* (Tl .* x10 - fl)) .* cos(x7) .^ 2 + (-g .* m .* (M + MR) .* cos(x5) + M .* sin(x5) .* (Tx .* x2 - fx)) .* m .* cos(x7) + (M + MR) .* (-m .* (-Ty .* x4 + fy) .* sin(x7) + (M .* x8 .^ 2 .* x9 - Tl .* x10 + fl) .* m - M .* (Tl .* x10 - fl))) ./ m ./ M ./ (M + MR) == 0;
%     Fl = solve(dx10);
% end
